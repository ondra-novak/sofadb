/*
 * replication.h
 *
 *  Created on: 14. 2. 2019
 *      Author: ondra
 */

#ifndef SRC_LIBSOFA_REPLICATION_H_
#define SRC_LIBSOFA_REPLICATION_H_
#include <string_view>


namespace sofadb {

///This interface defines replication protokol
/** The methods here are called by a replication client and they are implemented by replication
 * server. The implementation can be also provided through the network connection. For both
 * sides transfer method is transparent
 *
 *
 *
 * Replication
 * -------------
 * TWO modes
 *
 * 1) client --> server
 * 2) client <-- server
 *
 * The replication is always controlled by the client. Server just carries out the commands
 *
 * 1) mode client --> server
 * 1.1) client generates manifest of chanegs. For first replication, it generates manifest of
 * while database, other replications requires only changes
 * 1.2) client sends manifest to the server
 * 1.3) server returns list of documents that are looks newest by the manifest (it can also
 *      request conflicted documents in order to merge)
 * 1.4) client sends each requested document and receives status
 * 1.5) in case, that conflict is detected, client recives top level document in order to merge
 *
 * 2) mode client <-- server
 * 2.1) client requests the manifest since given seqnum
 * 2.2) client receives manifest and finds updated documents
 * 2.3) client requests these documents
 * 2.4) client receives these documents and stores them
 *
 */

class IReplicationProtocol {
public:


	struct Manifest {
		SeqNum seqNum;
		std::string_view docid;
		std::basic_string_view<std::string_view> revids;
	};

	using Manifest = std::basic_string_view<Manifest>;



	///Called when manifest arrives
	using ManifestCallback = std::function<void(const Manifest &manifest)>;
	///Called for all documents requested by other side
	/**
	 * Function is called as result of sendMyManifest. It receives list of seqnums which
	 * should contain documents to transfer to the server
	 */
	using DocRequestCallback = std::function<void(const std::basic_string_view<SeqNum> &)>;
	///Called as result to requst a document
	/**
	 * @param doc document. If the value is undefined, then document was not found
	 */
	using DocCallback = std::function<void(const json::Value &)>;
	///Called as result to send a document
	/**
	 * @param status result of receiving document
	 */
	using SendDocCallback = std::function<void(Status )>;


	///Request manifest from other side
	/**
	 * Useful to receive list of changed documents
	 *
	 * @param since seqnum of last item in previous manifest or zero. This avoids to reading
	 * the whole database during repeated calls
	 * @param limit limit of result because the single result can be huge. The replication can
	 *    be restarted from last change
	 * @param timeout specify timeout while waiting for new change, this applies when databases
	 * 	are in sync and there is process providing live replication. This allows to request to
	 * 	block for specified timeout or until the change is detected
	 * @param cb callback is called with result. Callback can be called synchronously
	 * or asynchronously. Prepare for both possibilites
	 */
	virtual void requestManifest(SeqNum since, std::size_t limit, std::size_t timeout, ChangeCallback &&cb) = 0;
	///Send my changes to the other database
	/** this is used to send my database to the other node while other node is still in server
	 * mode.
	 *
	 * @param manifest manifest generated by my changes
	 * @param cb function receives list of sequences of documents interested by the server
	 */
	virtual void sendMyManifest(const Manifest &manifest, DocRequestCallback &&cb) = 0;

	///Sends request for the document
	/**
	 *
	 * @param docid document id
	 * @param revid revision id
	 * @param cb callback function containing the document. Function can be called asynchronously
	 */
	virtual void requestDoc(const std::string_view &docid, const std::string_view &revid, DocCallback &&cb) = 0;
	///Sends the document to the server
	/**
	 * @param doc document's json
	 * @param history true to store document to history, false to mark newest document
	 * @param cb called with result of operation.
	 */
	virtual void sendDoc(const json::Value &doc, bool history, SendDocCallback &&cb) = 0;





};

}




#endif /* SRC_LIBSOFA_REPLICATION_H_ */
